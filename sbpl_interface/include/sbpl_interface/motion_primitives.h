/*********************************************************************
 * Software License Agreement (BSD License)
 *
 *  Copyright (c) 2014, Michael Ferguson
 *  Copyright (c) 2008, Maxim Likhachev
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.
 *   * Neither the name of University of Pennsylvania nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 *********************************************************************/

#ifndef _MOVEIT_SBPL_INTERFACE_MOTION_PRIMITIVES_H_
#define _MOVEIT_SBPL_INTERFACE_MOTION_PRIMITIVES_H_

namespace sbpl_interface
{

#include <vector>

enum motion_primitive_types
{
  STATIC,
  SNAP_TO_JOINT,
  SNAP_TO_XYZRPY,
  SNAP_TO_RPY
};

/** \brief Base class for a motion primitive */
class MotionPrimitive
{
public:
  MotionPrimitive(int type) : type_(type)
  {
  }

  virtual ~MotionPrimitive()
  {
  }

  /**
   *  \brief Get the successor state generated by this motion primitive.
   *  \param start The starting state.
   *  \param end The generated state (to be returned to caller).
   *  \param dist The end effector distance that starting state is from
   *         goal, in the dijkstra/euclidean space (in meters).
   *  \returns True if a successor is generated.
   */
  virtual bool getSuccessorState(const std::vector<double>& start,
                                 std::vector<double>* end,
                                 double dist)
  {
    *end = start;  // this is truly a stupid, worthless motion primitive
    return true;
  }

  int type()
  {
    return type_;
  }

protected:
  int type_;
};

typedef boost::shared_ptr<MotionPrimitive> MotionPrimitivePtr;

/** \brief This is the classical "move one joint a bit of distance" primtive. */
class StaticMotionPrimitive : public MotionPrimitive
{
public:
  /**
   *  \brief Construct the motion primitive.
   *  \param action The action to take, this is vector that is added to
   *         the starting state of a getSuccessorState call.
   *  \param lower_thresh If dist is below this thresh, do not apply primitive.
   *         These are considered "lower dimensional" primitives in the paper.
   *  \param upper_thresh If dist is above this thresh, do not apply primitive.
   */
  StaticMotionPrimitive(const std::vector<double>& action,
                        double lower_thresh = -1000.0,
                        double upper_thresh = 1000.0) :
    MotionPrimitive(STATIC),
    action_(action),
    lower_(lower_thresh),
    upper_(upper_thresh)
  {
  }

  virtual bool getSuccessorState(const std::vector<double>& start,
                                 std::vector<double>* end,
                                 double dist)
  {
    if (dist > upper_)
      return false;
    if (dist < lower_)
      return false;

    end->resize(start.size());
    for (size_t i = 0; i < action_.size(); ++i)
      (*end)[i] = start[i] + action_[i];

    return true;
  }

private:
  std::vector<double> action_;
  double lower_, upper_;
};

/** \brief For joint angle based requests, snap to the goal joint positions. */
class SnapToJointMotionPrimitive : public MotionPrimitive
{
public:
  /**
   *  \brief Setup a snap to joint motion primitive.
   *  \param goal The joint angles of the goal configuration.
   *  \param xyz_threshold The xyz distance (in meters) must be below this
   *         threshold in order to snap.
   */
  SnapToJointMotionPrimitive(const std::vector<double>& goal,
                             double xyz_threshold) :
    MotionPrimitive(SNAP_TO_JOINT),
    action_(goal),
    thresh_(xyz_threshold)
  {
  }

  virtual bool getSuccessorState(const std::vector<double>& start,
                                 std::vector<double>* end,
                                 double dist)
  {
    if (dist > thresh_)
      return false;

    *end = action_;
    return true;
  }

private:
  std::vector<double> action_;
  double thresh_;
};

}  // namespace sbpl_interface

#endif  // _MOVEIT_SBPL_INTERFACE_MOTION_PRIMITIVES_H_
